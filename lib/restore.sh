#!/usr/bin/env bash
# ============================================================================
# Backupd v3.0 - Restore Module
# Restic-based restore execution functions
#
# v3.0 Changes:
#   - Uses unified restore.sh script generated by generators.sh
#   - Restic snapshots replace legacy tar+gpg archives
#   - Interactive snapshot selection with 'latest' option
# ============================================================================

# ---------- Run Restore ----------

run_restore() {
  log_func_enter
  debug_enter "run_restore"
  print_header
  echo "Restore from Backup (Restic)"
  echo "============================"
  echo

  if ! is_configured; then
    print_error "System not configured. Please run setup first."
    press_enter_to_continue
    return
  fi

  # Check for unified restore script
  if [[ -f "$SCRIPTS_DIR/restore.sh" ]]; then
    echo "Launching restore interface..."
    echo
    bash "$SCRIPTS_DIR/restore.sh"
  else
    # Fallback: offer inline restore menu if script not found
    print_warning "Restore script not found. Running inline restore..."
    echo
    run_inline_restore
  fi
}

# ---------- Inline Restore (Fallback) ----------
# Used when generated restore.sh is not available

run_inline_restore() {
  # Source restic module if not already loaded
  [[ -z "${RESTIC_MODULE_LOADED:-}" ]] && source "$LIB_DIR/restic.sh" && RESTIC_MODULE_LOADED=1

  # Get configuration
  local secrets_dir rclone_remote rclone_db_path rclone_files_path
  secrets_dir="$(get_secrets_dir)"
  rclone_remote="$(get_config_value 'RCLONE_REMOTE')"
  rclone_db_path="$(get_config_value 'RCLONE_DB_PATH')"
  rclone_files_path="$(get_config_value 'RCLONE_FILES_PATH')"

  # Get restic password
  local restic_password
  restic_password="$(get_secret "$secrets_dir" ".c1")"
  if [[ -z "$restic_password" ]]; then
    print_error "Repository password not found"
    press_enter_to_continue
    return
  fi

  echo "1. Restore database(s)"
  echo "2. Restore files/sites"
  echo "3. List all snapshots"
  echo "4. Back to main menu"
  echo
  read -p "Select option [1-4]: " restore_choice

  case "$restore_choice" in
    1)
      if [[ -z "$rclone_db_path" ]]; then
        print_error "Database backups not configured"
        press_enter_to_continue
        return
      fi
      local db_repo="rclone:${rclone_remote}:${rclone_db_path}"
      echo
      echo "Database Snapshots:"
      echo "-------------------"
      RESTIC_PASSWORD="$restic_password" restic -r "$db_repo" snapshots --tag database 2>/dev/null || echo "No snapshots found or repository not initialized"
      echo
      echo "To restore, enter snapshot ID (or 'latest'):"
      read -p "> " snapshot_id
      if [[ -n "$snapshot_id" ]]; then
        echo
        echo "WARNING: This will restore the database. Continue? [y/N]"
        read -p "> " confirm
        if [[ "$confirm" =~ ^[Yy] ]]; then
          inline_restore_database "$db_repo" "$restic_password" "$snapshot_id" "$secrets_dir"
        fi
      fi
      press_enter_to_continue
      ;;
    2)
      if [[ -z "$rclone_files_path" ]]; then
        print_error "Files backups not configured"
        press_enter_to_continue
        return
      fi
      local files_repo="rclone:${rclone_remote}:${rclone_files_path}"
      echo
      echo "Files Snapshots:"
      echo "----------------"
      RESTIC_PASSWORD="$restic_password" restic -r "$files_repo" snapshots --tag files 2>/dev/null || echo "No snapshots found or repository not initialized"
      echo
      echo "To restore, enter snapshot ID (or 'latest'):"
      read -p "> " snapshot_id
      if [[ -n "$snapshot_id" ]]; then
        echo
        echo "Restore to original location or custom path?"
        echo "  1) Original location (WARNING: overwrites!)"
        echo "  2) Custom path"
        read -p "> " restore_type
        local target_path="/"
        if [[ "$restore_type" == "2" ]]; then
          read -p "Enter target path: " target_path
          [[ -z "$target_path" ]] && target_path="/tmp/restore-$(date +%s)"
          mkdir -p "$target_path"
        fi
        echo
        echo "WARNING: This will restore files to '$target_path'. Continue? [y/N]"
        read -p "> " confirm
        if [[ "$confirm" =~ ^[Yy] ]]; then
          inline_restore_files "$files_repo" "$restic_password" "$snapshot_id" "$target_path"
        fi
      fi
      press_enter_to_continue
      ;;
    3)
      echo
      if [[ -n "$rclone_db_path" ]]; then
        echo "Database Repository Snapshots:"
        echo "------------------------------"
        local db_repo="rclone:${rclone_remote}:${rclone_db_path}"
        RESTIC_PASSWORD="$restic_password" restic -r "$db_repo" snapshots 2>/dev/null || echo "Not available"
        echo
      fi
      if [[ -n "$rclone_files_path" ]]; then
        echo "Files Repository Snapshots:"
        echo "---------------------------"
        local files_repo="rclone:${rclone_remote}:${rclone_files_path}"
        RESTIC_PASSWORD="$restic_password" restic -r "$files_repo" snapshots 2>/dev/null || echo "Not available"
      fi
      press_enter_to_continue
      ;;
    4|*)
      return
      ;;
  esac
}

# ---------- Inline Restore Helpers ----------

inline_restore_database() {
  local repo="$1"
  local password="$2"
  local snapshot_id="$3"
  local secrets_dir="$4"

  # Setup cleanup trap for temp files (credential security)
  local MYSQL_AUTH_FILE="" temp_sql=""
  cleanup_restore_temp_files() {
    [[ -f "${temp_sql:-}" ]] && rm -f "$temp_sql"
    [[ -f "${MYSQL_AUTH_FILE:-}" ]] && rm -f "$MYSQL_AUTH_FILE"
  }
  trap cleanup_restore_temp_files RETURN EXIT INT TERM

  # Resolve 'latest' to actual snapshot ID
  if [[ "$snapshot_id" == "latest" ]]; then
    snapshot_id="$(RESTIC_PASSWORD="$password" restic -r "$repo" snapshots --tag database --json --latest 1 2>/dev/null | grep -o '"short_id":"[^"]*"' | head -1 | cut -d'"' -f4)"
    if [[ -z "$snapshot_id" ]]; then
      print_error "Could not find latest snapshot"
      return 1
    fi
    echo "Using latest snapshot: $snapshot_id"
  fi

  # Detect database client
  local DB_IMPORT
  if command -v mariadb >/dev/null 2>&1; then
    DB_IMPORT="mariadb"
  elif command -v mysql >/dev/null 2>&1; then
    DB_IMPORT="mysql"
  else
    print_error "No database client found"
    return 1
  fi

  # Get database credentials
  local DB_USER DB_PASS
  DB_USER="$(get_secret "$secrets_dir" ".c2" || echo "")"
  DB_PASS="$(get_secret "$secrets_dir" ".c3" || echo "")"
  local MYSQL_ARGS=()

  if [[ -n "$DB_USER" && -n "$DB_PASS" ]]; then
    MYSQL_AUTH_FILE="$(mktemp)"
    chmod 600 "$MYSQL_AUTH_FILE"
    cat > "$MYSQL_AUTH_FILE" << AUTHEOF
[client]
user=$DB_USER
password=$DB_PASS
AUTHEOF
    MYSQL_ARGS=("--defaults-extra-file=$MYSQL_AUTH_FILE")
  fi

  # Get database name from snapshot tags
  local db_name
  db_name="$(RESTIC_PASSWORD="$password" restic -r "$repo" snapshots "$snapshot_id" --json 2>/dev/null | grep -o 'db:[^"]*' | head -1)"
  db_name="${db_name#db:}"
  [[ -z "$db_name" ]] && db_name="unknown"

  # Create temp file for SQL dump
  local temp_sql
  temp_sql="$(mktemp --suffix=.sql)"
  chmod 600 "$temp_sql"

  echo "Extracting database '$db_name' from snapshot..."
  if RESTIC_PASSWORD="$password" restic -r "$repo" dump "$snapshot_id" "/${db_name}.sql" > "$temp_sql" 2>/dev/null; then
    local sql_size
    sql_size="$(stat -c%s "$temp_sql" 2>/dev/null || echo 0)"
    echo "Extracted $(numfmt --to=iec "$sql_size" 2>/dev/null || echo "$sql_size bytes")"

    echo "Importing database..."
    if $DB_IMPORT "${MYSQL_ARGS[@]}" < "$temp_sql" 2>&1; then
      # Post-restore verification: check tables exist
      local safe_db_name="${db_name//\'/}"
      local table_count
      table_count=$($DB_IMPORT "${MYSQL_ARGS[@]}" -N -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='$safe_db_name'" 2>/dev/null || echo "")
      table_count=$(echo "$table_count" | tr -d '[:space:]')
      if [[ -n "$table_count" && "$table_count" -gt 0 ]]; then
        print_success "Database restored successfully ($table_count tables verified)"
      elif [[ "$db_name" == "unknown" ]]; then
        print_success "Database restored successfully"
      else
        print_warning "Database imported but no tables found in '$db_name'"
      fi
    else
      print_error "Database import failed"
    fi
  else
    print_error "Failed to extract database from snapshot"
  fi
  # Cleanup handled by trap set at function start
}

inline_restore_files() {
  local repo="$1"
  local password="$2"
  local snapshot_id="$3"
  local target_path="$4"

  # Resolve 'latest' to actual snapshot ID
  if [[ "$snapshot_id" == "latest" ]]; then
    snapshot_id="$(RESTIC_PASSWORD="$password" restic -r "$repo" snapshots --tag files --json --latest 1 2>/dev/null | grep -o '"short_id":"[^"]*"' | head -1 | cut -d'"' -f4)"
    if [[ -z "$snapshot_id" ]]; then
      print_error "Could not find latest snapshot"
      return 1
    fi
    echo "Using latest snapshot: $snapshot_id"
  fi

  echo "Restoring files to $target_path..."
  local restore_output
  if restore_output=$(RESTIC_PASSWORD="$password" restic -r "$repo" restore "$snapshot_id" --target "$target_path" 2>&1); then
    # Post-restore verification: check files exist (bounded to avoid slow traversal on large restores)
    local file_count
    file_count=$(find "$target_path" -maxdepth 3 -type f 2>/dev/null | head -100 | wc -l)
    if [[ "$file_count" -gt 0 ]]; then
      local count_suffix=""
      [[ "$file_count" -ge 100 ]] && count_suffix="+"
      print_success "Files restored successfully to $target_path (${file_count}${count_suffix} files verified)"
    else
      print_warning "Restore completed but no files found in $target_path"
    fi
  else
    # Sanitize output before displaying (hide sensitive paths)
    print_error "Files restore failed"
    log_error "Restore failed: $(echo "$restore_output" | head -5)"
  fi
}
